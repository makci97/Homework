В этом видео мы познакомимся
с типами данных в «Питоне». И начнем, конечно,
с числовых типов данных. Допустим, нам нужно завести переменную,
в которой будет некоторое целое число, ну, например, количество чего-нибудь. Ну это очень просто. Давайте ее выведем на печать
теперь и посмотрим ее тип. Тип у нее int. С int-овыми переменными можно выполнять
некоторые простые операции: складывать, умножать, делить. При этом, если результат сложения и
умножения был действительно предсказуем, то результат деления может
вас немного удивить. На самом деле, все достаточно логично. Если мы разделили int-овое
число на int-овое число, то должны были получить тоже int,
поэтому здесь деление целочисленное. Если мы попробуем поделить отрицательное
число, то получим вот такой вот ответ. Если же вы хотите получить
−1 в данном примере, то нужно взять деление 5 на 4 в скобки. Тогда сначала произойдет это деление,
а потом уже будет умножение на −1. Кроме того, может быть, вам придется
работать с достаточно большими числами. Большие числа будут,
скорее всего, иметь тип long, но так как в «Питоне»
динамическая типизация, и в одну переменную можно записать
сначала один тип, потом другой, (вот давайте это проверим для
нашего примера с большим числом), то можно особо не переживать из-за того,
какой же там тип, int или long. Ну и, конечно,
в «Питоне» есть дробные числа. Они представлены типом float. С ними тоже можно делать простые
операции: сложение, умножение, деление. Ну и, конечно,
здесь уже деление не целочисленное. И отсюда возникает идея: если вам нужно
получить нецелочисленное деление, а аргументы у вас целые, то можно попробовать каждый
аргумент привести к типу float. Но тогда получится действительно
дробный результат. И при этом можно лишь один
аргумент приводить к типу float, потому что в таком случае
результат будет таким, чтобы вроде как ничего
ценного не потерялось. Ну а раз один из аргументов —
действительно дробное число, то, наверное, логично, что и результат
должен быть дробным. Кроме того,
в «Питоне» есть логический тип данных, bool, я его рассказываю вместе
с числовыми, ну хотя бы потому, что bool легко можно привести к типу int,
ну и потому, что если мы попробуем
поскладывать разные значения, то мы получим вот такой
вот интересный результат. То есть, оказывается,
true + true будет равно двум. Ну, в самом деле,
если мы приведем к int, то мы убедимся, что true это у нас единичка,
а false это у нас 0. Кстати, обратите внимание, true и false
в «Питоне» пишутся с большой буквы. Ну а здесь при сложении у нас сначала
произошло неявное приведение к типу int. Ну и, конечно, есть обычные привычные
операции с логическим типом. Это операция «и», «или». Давайте убедимся, что результаты такие,
как обычно и продолжим дальше. В «Питоне» есть тип none. Это не 0 и не false. Это специальный тип,
который означает отсутствие значения, у него даже свое название типа: NoneType. И его, конечно же, не получится
привести к какому-то другому типу. Но как один из примеров того,
откуда может взяться none, можно присвоить какой-нибудь переменный
результат вычисления функций, которая ничего не возвращает. О функциях мы еще поговорим
подробнее в следующем видео. Ну и, конечно,
вы можете записывать переменные строки. Для этого есть тип str. С ним тоже есть какие-то простые операции,
тоже можно складывать, но для строк сложение означает уже
дописывание к одной строке другой строки. Можно приводить к нижнему
регистру или к верхнему регистру. Можно получить длину строки. Можно привести к типу bool,
если строка имеет не нулевую длину, то есть не пустая строка,
то результат будет true. В противном случае, то есть для
пустой строки, результат будет false. Ну и, конечно, приводить к
числовому типу уже не получается. Можно получать различные элементы строки (ну вот здесь вот мы получили нулевой
и первый элемент) или делать срез, то есть получать некоторый
диапазон элементов. Смотрите, здесь мы сделали срез
с нулевого по третий элемент. Третий элемент в итоге не включается. Ну и в срезе можно использовать
еще один параметр. Это шаг. В этом случае мы получаем нулевой элемент, затем 0 + 2 получается
элемент с индексом 2. Ну и 2 + 2 уже получается 4,
а мы идем до 4 не включая. Вот поэтому получается такой результат. Есть еще один тип данных для строк,
это unicode. Для этого вам нужно
дописать перед строкой u. И вот, действительно,
получается тип данных unicode. Но если вы знакомы с кодировками,
то, конечно, вы понимаете, зачем может понадобиться этот тип данных. Ну, кроме того, любопытно,
как переходить от типа unicode к типу str. Ну давайте объявим некоторую юникодную
строку, посмотрим, что действительно она юникодная, и применим
метод encode для того, чтобы получить str,
и укажем кодировку utf8. Выведем на печать и увидим,
что все хорошо. encode действительно делает
из юникодной строки str. Ну а операция decode делает
из str юникодную строку. При этом обратите внимание,
если мы неверно укажем кодировку, ну, например, cp1251, которая,
как правило, используется в Windows, то мы получим немного странный результат. Можно подумать, что можно было
просто явно привести к типу str, но это неправда, действительно,
ничего не срабатывает. Ну и на всякий случай, если вы не очень плотно знакомы с
кодировками, давайте посмотрим, что будет, если мы в той строке, которая имеет тип
str, возьмем срез с первого элемента. Вот смотрите,
первая буква у нас почему-то сломалась. И, кстати,
если мы посмотрим на длину строки, то для типа str она получилась одна,
а для типа unicode другая. Дело вот в чем. Некоторые символы кодируются двумя
байтами, некоторые — одним байтом. Тип данных unicode знает об этом,
тип данных str не знает, и поэтому когда мы выводим
длину для объекта типа str, то мы получаем несколько большее число, потому что некоторые буквы считались,
получается, 2 раза. Ну и, кроме того, когда мы сделали
decode с неправильной кодировкой, нам еще очень повезло. Ну вот смотрите. Допустим, у нас есть юникодная строка,
вот мы сделали encode, получили str. Ну и теперь давайте попробуем сделать
decode с правильной кодировкой. Все работает. А теперь попробуем сделать с неправильной. И, смотрите,
в этом случае уже все сломалось. То есть просто та строка была более
удачной для такого рода ошибки. Ну, как вы видите, бывают ситуации, когда
мы получаем сообщение об ошибке, бывают ситуации, когда мы не получаем сообщение
об ошибке и как-то неправильно декодируем. Конечно, это один из основных
камней преткновения в выборе между вторым «Питоном» и третьим «Питоном»,
и многие сторонники третьего «Питона», в котором такой проблемы нет,
и в котором один тип для строк, приводят это как аргумент
в пользу третьего «Питона». Но на самом деле и за тот,
и за другой аргументов много, и выбор — это скорее вопрос вкуса. Выбирайте то, что вам больше нравится, но мы продолжим для единообразия
повествования на втором «Питоне». Итак. Давайте посмотрим еще на одну операцию. Это операция split. Она разбивает строчку по
какой-то другой строке. Кстати, обратите внимание,
я еще не делал замечания, но строки в «Питоне» можно
писать как в двойных кавычках, так и в одинарных кавычках,
и вот это достаточный результат. Теперь мы получили какой-то объект,
который имеет тип, с которым мы до этого не сталкивались. Давайте посмотрим на его тип. Тип list. Забегая вперед, скажу, что это массив, и это не имеет никакого отношения к
спискам из алгоритмов и структур данных. Ну и давайте попробуем сделать
то же самое для русского текста. И увидим, что когда мы выводим
массив с русскоязычными строчками, то мы получаем
не очень читаемый вид. Давайте попробуем напечатать вот
какой–то один фрагмент, видим, что это получается буква И. Вот, когда мы отсекли первый элемент, мы фактически попытались
убрать вот эту часть, ну, действительно, получается что-то другое, ну а если мы делаем то же
самое с юникодной строкой, то здесь уже кодируется
немного по-другому. Ну раз уж мы столкнулись с массивом,
давайте познакомимся с массивами. Одним из типов для массивов — это list. Ну что мы можем хранить в массивах? Мы можем хранить какие-то числа, ну,
например, количество проданных товаров в разные дни, можем хранить какие-то
строчки, например, уровень дохода разных людей, которые хотят взять кредит или
брали когда-то кредит, или их имена. Ну и здесь мы опять получили
какой-то не очень читаемый вывод, поэтому давайте
воспользуемся методом join, который есть у строчек и позволяет просто соединить элементы массива
какой-то другой строкой. Давайте посмотрим, что получится. Ну, если б мы взяли не пробел,
а что-нибудь другое, то получилось бы вот так. Ну в дальнейшем,
чтобы не заморачиваться с выводом, будем использовать английские символы, ну эта проблема, как вы видите,
решается несложно. list позволяет хранить
объекты разных типов. Зачем это может быть нужно? Ну, например, если вам нужно
хранить описание опять-таки людей, которые брали когда-то кредиты, то у вас
разные параметры могут иметь разные типы, ну, например, имя будет строковым
параметром, время, на которое хочется взять кредит будет числом, а вернул или
нет может быть булевским параметром. Ну и давайте посмотрим,
как работает индексация. Индексация работает также как в строчках, мы действительно получаем
элемент какой нужно по индексу, действительно можем делать срез также,
как в строчках, можем делать срез до какого-то
элемента или от какого то элемента, и можем использовать
индексацию с конца массива. Также можем добавлять элемент
массива с помощью метода append и удалять элементы. Кроме того, есть еще один тип данных
для массивов — это тип данных tuple. Давайте его создадим, проверим, что работают те же операции среза,
ну и попробуем добавить элементы. Здесь все закончилось не очень удачно,
мы получили сообщение об ошибке, выяснили, что атрибута append вообще нет,
и у нас, естественно, возникает вопрос: зачем же нужен такой массив,
в который нельзя добавить новый элемент? Давайте продолжим и вскоре мы узнаем,
зачем же нужен tuple. Итак, кроме того,
в Python есть другие типы данных, а именно — множества и словари. Ну давайте начнем с множеств. Допустим, вы хотите создать переменную
в которой будут храниться разные имена людей. Давайте убедимся что это set. Вот как вы видите в Python можно
использовать не только квадратные скобки и круглые для объявления разных
типов данных, но еще и фигурные, но и давайте посмотрим что получится, если мы проверим наличие
какого-то элемента множеств. Вот мы получаем булевский
ответ в зависимости от того, есть элемент или его нет. Можно элемент попробовать добавить
и видеть, что все успешно, можно попробовать добавить тот элемент,
который уже есть в множестве и увидеть, что конечно новый элемент не появился,
потому что элемент уже есть, то есть дубликата множеств нет,
можно удалять элементы. Можно попробовать добавить элемент
какого-то другого типа по сравнению с теми, которые уже представлены. Это можно сделать с множеством
точно также как с листом, но в примере, который мы сейчас запустим,
ничего не получится, и мы получим сообщение об
ошибке unhashable type list. Ну за такие алгоритмы и структур
данных уже могли догадаться, что это связано с тем, что множество реализовано
с помощью структур данных хеш-таблицы, и поэтому нужно, чтобы от добавляемого
элемента можно было взять hash, то есть, чтобы элемент был неизменяемым, но если эти слова ничего для вас не
говорят, достаточно просто запомнить, что изменяемые элементы
добавлять в set нельзя. Но если мы попробуем добавить tuple,
то всё получится удачно. Но можно подумать,
зачем нам нужно множество? Могли бы просто содержать какой-то
массив и поддерживать то, что в массиве не будет дубликатов,
ну а если нужно, пробегаться по массиву и смотреть,
есть ли там элементы. Но, конечно,
это будет работать намного медленнее. Для этого попробуем сравнить ситуацию:
создадим массив из чисел от нуля до десяти тысяч не включая и множество с числами
от нуля до десяти тысяч не включая. Это можно сделать с помощью функции range. Ну давайте убедимся,
что в массиве все что нужно, выведем первый элемент и последний,
ну и теперь замерим время, за которое мы можем проверить, что какой-то элемент
есть в массиве и есть множество. Разница колоссальная. Ну и кроме того, есть в Python
тип данных dict — это словарь. Он пригодится нам, если нужно хранить какое-то отображение из
одних элементов в другие, ну, например, для каждого слова уметь быстро получать
его частоту в каком-нибудь тексте. При этом можно получать элемент по какому-то ключу и как выводить
его на печать, так и обновлять значения. Ну и можно создавать множество,
опять же, с помощью фигурных скобок, и можно хранить в множестве
разные элементы и ключом, опять-таки, должен быть неизменяемый тип,
ну то есть использовать tuple в качестве ключа можно, использовать
list в качестве ключа — неудачная затея. Если Вам хочется
познакомиться с Python еще более подробно или
послушать другие изложения, то материала по Python
очень много в Интернете, есть курсы на coursera, есть codeacademy, есть другие ресурсы, некоторые из
этих ресурсов по третьему Python. Если Вам захочется ознакомиться и
сравнить, можете ими воспользоваться.